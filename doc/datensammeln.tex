\chapter{Datenverarbeitung}

Wie bei jeder Anwendung von maschinellen Lernverfahren sind die zugrundeliegenden Daten von äußerster Wichtigkeit.
Im Rahmen dieser Masterarbeit wurden zweierlei Sorten von Daten benutzt:
Einmal wurden am \textit{TableSort} Schüttgutsortierer des Fraunhofer IOSBs Aufnahmen gemacht, 
die dann über mehrere Arbeitsschritte in das richtige Datenformat übersetzt wurden.
Zudem existieren der DEM Datensatz \todo{mehr details - Quellen lesen}



\section{Datenformatierung}


\begin{itemize}
	\item Zu Beginn des Datenverarbeitungskapitel erstmal definieren wie unsere Feature-Label Paare aussehen.
	\item Features eigentlich immer gleich:
	\item die Positionen der letzten \(n\) Zeitschritte (FeatureSize Hyperparameter)
	\item also ein \(2n\) Tupel, mit jeweils \(n\) X-Koordinaten und \(n\) Y-Koordinaten

\end{itemize}


Labels: Unterscheidung nach Anwendung:

NextStep: Label ist 2-Tupel, X und Y Koordinate
Separator: 
	gegeben ist eine Stelle entlang der Bewegungsrichtung der Teilchen an der der Separator angebracht ist.
	erstes element des Label ist die Koordinate entlang der orthogonalen Achse zur Bewegungsrichtung wo das Teilchen den Separator passiert
	zweites Element ist die Anzahl von Zeitschritten , die das Teilchen noch bis zum Separator braucht.

Important Point: Labels wurden normalisiert und Standardisiert ( \(\frac{TrueVal - Mean}{Standard Diviation}\)
um auszugleichen, dass sich Position und Zeitschritte auf unterschiedlichen Skalen bewegen und dementsprechend unterschiedlich hohe gradienten haben.


Es ist implementiert, dass die verschiedenen Dimensionen unterschiedlich stark gewichtet werden können - Je nach Schüttgut/präzision des Separators
Aber für die evaluierung ist keine Gewichtung vorgenommen worden.

optional: Histogramme über die Daten (mehr Teilchen in der Mitte bei Location...)



\section{Eigene Aufnahmen}

\subsection{Versuchsaufbau}

\begin{itemize}
	\item Am TableSort System, einmal Band, einmal Rutsche
	\item Beschreibung von der Bonito Kamera, stats usw.
	\item Umrechengröße pixel zu mm
	\item Bandgeschwindigkeit
\end{itemize}

\color{blue}
Zur Aufnahme der Daten wurde eine Bonito CL-400 200 FPS Kamera benutzt, die in Abbildung \ref{pictureCam} zu sehen ist.
Die ist, wie in Abbildung \ref{fig:tablesortsystem} oberhalb des Förderbandes angebracht.
Die Bilder, die von der Kamera aufgenommen werden, haben eine Auflösung von 2320x1726 Pixeln \cite{alliedvisiontechnologiesgmbh2014}.
\todo[inline]{Umrechengröße pixel zu mm, im weiteren verlauf werden pixel benutzt}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/banner-Bonito_cropped}
    \caption{Zur Aufnahme verwendete Kamera [TODO: Quelle Bild]}
    \label{pictureCam}
\end{figure}

\subsection{Schüttgüter-Typen}

Aufgenommen wurden vier verschiedene Schüttgüter, die in Abbildung \ref{fig:schuettgueterSchuessel} zu sehen sind.

\begin{itemize}
    \item Kugeln
    \item grüne Pfefferkörner
    \item Zylinder
    \item Weizenkörner
\end{itemize}

Die Kugeln und der Pfeffer sowie die Zylinder und die Weizenkörner bilden jeweils 
ein Paar aus einem geometrischen Körper und einem echten Objekt, das grob dessen Form ähnelt.

Die Kugeln bestehen aus Holz und haben einen Durchmesser von 5mm.
Die Zylinder bestehen ebenfalls aus Holz. Sie haben eine Länge von 1cm und einen Durchmesser von 3mm.
Die Schüttgüter sind in Abbildung \ref{fig:schuettgueterSchuessel} in Schüsseln 
und in Abbildung \ref{fig:schuettgueterBand} auf dem Förderband zu sehen.
\todo{TODO: Details}

\begin{figure}[h]
	\centering
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{kugel_001_00084_debayer}
		\caption{Kugeln}
	\end{subfigure}
	\quad
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{Pfeffer_003_00020_debayer}
		\caption{Pfeffer}
	\end{subfigure}
	\vskip\baselineskip
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{zylinder_001_00009_debayer}
		\caption{Zylinder}
	\end{subfigure}
	\quad
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{weizen_004_00016_debayer}
		\caption{Weizen}
	\end{subfigure}
	\caption{Verschiedene Schüttgüter auf dem Förderband}
	\label{fig:schuettgueterBand}
\end{figure}

\color{black}
\section{Datenpipeline}

\begin{itemize}
	\item Beschreiben wie aus den Bildern die relevanten Features extrahiert werden.
	\item Ursprungs: Bayer Matrix Bitmap
	\item Konvert to RGB
	\item Segmentierungsskript zu CSV No.1
	\item TrackSort Algorithmus zuweisung zu CSV No.2
	\item Das ist dann der finale Punkt von wo es in meinen Code geladen wird und der rest dort passiert 
\end{itemize}

\color{blue}
Die Bonito Kamera nimmt Bilder in Form einer Bayer-Matrix auf, wie sie in \ref{fig:bayerPattern} zu sehen ist.
Diese werden dann in Batches von je 3500 gesammelt und in Bitmap Dateien geschrieben.
\todo{hier Bayer-Matrix erklären und Bild?}

\begin{figure}
	% \missingfigure{bayer matrix}
	\centering
	\includegraphics[width=0.6\textwidth]{1024px-Bayer_pattern_on_sensor}
	\caption{Bayer Matrix [TODO: Quelle]}
	\label{fig:bayerPattern}
\end{figure}

Auf Grund der Menge an Bildern wurden die Bilder zunächst in das png Dateiformat übertragen.
Die Features, die für das Trainieren der Netze benutzt werden, sind die Koordinaten der Mittelpunkte der Objekte.
Um diese zu bestimmten, müssen zunächst die Dateien mittels \textit{demosaicing} rekonstruiert werden um gewöhnliche RGB Bilder zu erhalten.
Die Open Source Computer Vision Library OpenCV hat eine Methode implementiert, die ein Bild von einem Farbraum in einen anderen übertragen kann.
Diese wurde eingesetzt um die einzelnen Bilder in RGB Farbbilder zu konvertieren.
\todo[inline]{Skript ursprünglich von Georg, ein paar changes implementiert (bezüglich input und output.)}

\begin{figure}[h]
	\centering
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{KugelnCropped}
		\caption{Kugeln}
	\end{subfigure}
	\quad
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{PfefferCropped}
		\caption{Pfeffer}
	\end{subfigure}
	\vskip\baselineskip
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{ZylinderCropped}
		\caption{Zylinder}
	\end{subfigure}
	\quad
	\begin{subfigure}[t]{0.4\textwidth}
		\includegraphics[width=\textwidth]{WeizenCropped}
		\caption{Weizen}
	\end{subfigure}
	\caption{Verschiedene gesammelte Schüttgüter}
	\label{fig:schuettgueterSchuessel}
\end{figure}


Auf diesen kann dann eine Segmentierung vorgenommen werden.
Hierzu wurde erneut die Computer Vision Library OpenCV benutzt.
Für jede Sorte von Schüttgut wurde ein eigenes Parameterprofil von Hand angepasst.
Diese bestehen aus einem oberen und unteren Grenzwert in jedem Kanal des HSV-Raums und einer minimalen Fläche, die ein Teilchen umfassen muss.
Entsprechend der durch das Profil festgelegten Parameter werden für die einzelnen Bilder Masken angelegt,
ob die HSV-Werte der einzelnen Pixel innerhalb oder außerhalb der Grenzwerte liegen. 
Mit diesen Masken werden dann alle möglichen Konturen von Schüttgutpartikeln extrahiert, 
bevor diese nocheinmal bezüglich ihrer Sinnhaftigkeit gefiltert werden. 
Im letzten Schritt wird nun der gewichtete Mittelpunkt der einzelnen Konturen bestimmt und abgespeichert.
Das Ergebnis von diesem Segmentierungsscripts ist eine CSV Datei für jedes Batch.
Ein Beispiel für einen Ausschnitt aus solch einer Datei ist in Tabelle \ref{table:Segmentierungsscript} zu sehen.
Eine Zeile repräsentiert jeweils ein Bild aus dem Batch, also einen Zeitschritt.
Zu Beginn jeder Zeile steht zunächst die Frame Nummer, gefolgt von der Anzahl der detektierten Partikel
und den X- und Y-Koordinaten der Mittelpunkte der detektierten Partikel.

\begin{table}[]
    \caption{Ausschnitt aus dem Ergebnis des Segmentierungsscripts}
	\small
	\centering
    \begin{tabular}{@{}rcrrrrrr@{}}
    \toprule
    Frame   & \#MP & MP\_1\_x  & MP\_1\_y  & MP\_2\_x  & MP\_2\_y  & MP\_3\_x & MP\_3\_y \\ \midrule
    636     & 1    & 1222.9975 & 92.7641   & NaN       & NaN       & NaN      & NaN      \\
    637     & 1    & 1223.4063 & 182.9758  & NaN       & NaN       & NaN      & NaN      \\
    638     & 1    & 1223.6052 & 273.2425  & NaN       & NaN       & NaN      & NaN      \\
    639     & 1    & 1223.7067 & 364.0339  & NaN       & NaN       & NaN      & NaN      \\
    640     & 1    & 1224.0704 & 453.9057  & NaN       & NaN       & NaN      & NaN      \\
    641     & 2    & 1224.2051 & 544.5191  & 1692.4549 & 43.8822   & NaN      & NaN      \\
    642     & 2    & 1224.5793 & 634.7288  & 1696.6901 & 135.9595  & NaN      & NaN      \\
    643     & 2    & 1224.9082 & 726.0094  & 1700.451  & 229.1195  & NaN      & NaN      \\
    644     & 2    & 1225.2296 & 815.9663  & 1704.1472 & 321.2075  & NaN      & NaN      \\
    645     & 2    & 1225.4286 & 906.7078  & 1708.0593 & 414.2785  & NaN      & NaN      \\
    646     & 2    & 1225.7588 & 996.0286  & 1711.5309 & 506.0545  & NaN      & NaN      \\
    647     & 3    & 1226.0411  & 1086.5729 & 1714.8831 & 599.5417  & 961.8821 & 62.7111 \\
    648     & 3    & 1226.2337 & 1175.9271 & 1718.1401 & 691.6325  & 958.5526 & 154.3124 \\
    649     & 3    & 1226.2073 & 1265.7495 & 1721.6618 & 784.5927  & 955.3107 & 246.5241 \\
    650     & 3    & 1226.2543 & 1354.9362 & 1724.9158 & 876.7192  & 952.4919 & 338.1123 \\
    651     & 3    & 1226.2634 & 1444.5903 & 1728.3341 & 970.2909  & 949.2896 & 430.9692 \\
    652     & 3    & 1226.0845 & 1533.0901 & 1732.1745 & 1062.4624 & 946.3455 & 522.8667 \\
    653     & 3    & 1225.7319 & 1621.8461 & 1735.8759 & 1155.2937 & 943.3384 & 615.4545 \\
    654     & 2    & 1739.6714 & 1247.1867 & 940.2511  & 707.7306  & NaN      & NaN      \\
    655     & 2    & 1743.4279 & 1339.4146 & 937.2216  & 800.4557  & NaN      & NaN      \\
    656     & 2    & 1747.1525 & 1430.2501 & 934.5311  & 891.7249  & NaN      & NaN      \\
    657     & 2    & 1750.9771 & 1521.8102 & 931.6626  & 984.2284  & NaN      & NaN      \\
    658     & 2    & 1754.1491 & 1612.5565 & 928.7587  & 1076.4749 & NaN      & NaN      \\
    659     & 1    & 925.8463  & 1168.794  & NaN       & NaN       & NaN      & NaN      \\
    660     & 1    & 922.8752  & 1260.7461 & NaN       & NaN       & NaN      & NaN      \\
    661     & 1    & 920.2056  & 1352.8549 & NaN       & NaN       & NaN      & NaN      \\
    662     & 1    & 917.4051  & 1444.3431 & NaN       & NaN       & NaN      & NaN      \\
    663     & 1    & 914.6493  & 1535.5131 & NaN       & NaN       & NaN      & NaN      \\
    664     & 1    & 911.8565  & 1626.5341 & NaN       & NaN       & NaN      & NaN      \\ \bottomrule
    \end{tabular}
    \normalsize
    
    \label{table:Segmentierungsscript}
    \end{table}
    

Die Mittelpunkte in diesem CSV File werden nun mittels des in MATLAB implementierten TrackSort Algorithmus einzelnen Tracks zugeordnet,
\todo{Mehr details: Tracksort trackzuweisung Assignment Problem. Referenz Tobi MA?}
die dann wiederum in einem neuen CSV File gespeichert werden.
Die einzelnen Tracks werden als Spaltenpaare dargestellt mit jeweils einer Spalte für die X- und Y-Koordinaten zu einem jeweiligen Zeitpunkt.
Ein Ausschnitt aus einer solchen Datei ist in Tabelle \ref{table:table:tracksortCSV} zu sehen.



\begin{table}[]
	\caption{Ausschnitt aus dem Ergebnis des \textit{TrackSort} Algorithmus}
	\label{table:tracksortCSV}
    \small
    \centering
    \begin{tabular}{@{}rrrrrr@{}}
    \toprule
    TrackID\_4\_X & TrackID\_4\_Y & TrackID\_5\_X & TrackID\_5\_Y & TrackID\_6\_X & TrackID\_6\_Y \\ \midrule
    1036.4613     & 82.3719       & 1899.9239     & 83.2049       & 1654.4423     & 50.6811       \\
    1033.0189     & 174.9809      & 1896.8142     & 171.3283      & 1655.3193     & 143.9749      \\
    1029.6167     & 266.4979      & 1893.5937     & 259.8098      & 1656.0221     & 237.1573      \\
    1026.3908     & 358.4831      & 1890.3912     & 348.1731      & 1656.8966     & 329.8636      \\
    1023.0203     & 449.6429      & 1887.1035     & 436.4588      & 1657.6308     & 423.1592      \\
    1019.5391     & 542.2334      & 1883.7761     & 525.1073      & NaN           & NaN           \\
    NaN           & NaN           & 1880.2716     & 613.0896      & NaN           & NaN           \\
    NaN           & NaN           & 1876.6054     & 701.9719      & NaN           & NaN           \\
    NaN           & NaN           & NaN           & NaN           & NaN           & NaN           \\ \bottomrule
    \end{tabular}
\end{table}





\color{black}
\section{Simulierte Daten}

Die DEM Daten, wo sie herkommen, was der unterschied ist zu den selbstaufgenommenen Daten. 
Vorteile und Nachteile...\cite{pieper2016numerical}, \cite{pieper2017numerical} 

Original: 1000Hz, downsampled auf 200Hz, 

Nicht ganz so viele Partikel, aber dafür sehr lange tracks - Informationen auf dem gesamten Band, nicht nur auf dem Part wo die Kamera drauf schaut.

Vergleich bezüglich der Eignung für die verschiedenen Ansätze dann im Evaluations Kapitel

\begin{figure}
    \centering
    \missingfigure{DEM Simulationsgrafik}
	% \includegraphics[width=\textwidth]{NN_NextStep_v2}
	\caption{Visualisierung der DEM Simulation [TODO: QUELLE!]}
	\label{fig:DEMSimulation}
\end{figure}


\subsection{Menge}

Insgesamt wurden 265451 Bilder aufgenommen.
177951 Bilder auf dem Förderband
87500 Bilder auf der Rutsche


Anzahl separate Tracks.
Anmerkung: Simulationsdaten sind die echte Wahrheit, während die werte von den Selbstgesammelten Daten hier 
auf die Korrektheit des Outputs vom Tracksort Algorithmus beruhen. 

Es wurden 
7538 Kugeln in 15 Batches,
7056 Pfefferkörner in 13 Batches,
17049 Zylinder in 11 Batches
und 8549 Weizenkörner in 13 Batches aufgenommen.
\todo[inline]{das in eine Schöne Tabelle stecken und erzählen}

\todo[inline]{Table mit Anzahl von Elementen in verschiedenen Batches}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/scaledPieChart-trimmed}
    \caption{Verteilung Schüttgut Elemente nach Sorte}
    \label{piechartSchuettgut}
\end{figure}


% Menge in gecleanten Daten:

% 7343 Kugeln
% 6824 Pfefferkörner
% 15760 Zylinder
% 8426 Weizenkörner


\section{Daten Postprocessing}

Cleanup : FilterTracksByAngle, FilterByVectorLengthChange \todo{Überlegen ob ich da so viel aufschreiben soll - 
minimaler unterschied nach Resegment (Bessere Tracksort zuordnung?)}


\begin{itemize}
	\item Data Augmentation: Definition und Beschreibung
	\item bei Bildern normalerweise Rotieren, Translation, Ausschnitte...
	\item Hier: Spiegeln
	\item in einem Band - an der Mitte, nicht die Ränder mit nehmen - Kamera nicht perfekt zentriert
	\item führt zu: Beinah verdoppelung der Feature-Label-paare fürs training.
\end{itemize}

\color{blue}
Als Data Augmentation bezeichnet man Verfahren, die die eigenen Daten erweitern ohne zusätzliche Daten aufzunehmen.
Man generiert aus den bestehenden Daten zusätzliche, synthetische Daten, die dann im Trainingsset eingesetzt werden können.
Ausreichend viele Trainingsbeispiele zu haben ist notwendig um mit neuronalen Netzen eine gute Performance zu erzielen.
Die synthetischen Beispiele müssen jedoch plausibel sein, da sie sonst die Qualität der Ausgabe des Netzes negativ beeinträchtigen können.

Für Netze, die in der Bilderkennnung eingesetzt werden gibt es einige weit verbreitete Techniken,
zum Beispiel Rotation, Translation, Spiegeln und das Ausschneiden von Teilbildern.

Für den gegebenen Fall mit den Mittelpunkten von Schüttgut Partikeln als Features resultiert von diesen Techniken nur das Spiegeln in sinnvollen Daten.
gespiegelt wird an der Mittellinie entlang der Bewegungsrichtung.
Tracks, die [zu nah an den Rand kommen] werden ausgenommen, da zumindest bei den selbst aufgenommenen Daten, die Kamera nicht perfekt zentriert ist.

\begin{figure}
	% \missingfigure{Visualisierung Dataaugmentation}
	\centering
	\includegraphics[width=\textwidth]{augmentationImage}
	\caption{Visualisierung Data Augmentation durch Spiegelung}
	% \todo{Quelle Bild!}
	\label{fig:dataAugm}
\end{figure}


\color{black}
\section{Trainingsbeispiele}

Train - Test - Validation - Split:
Train - test, 90\% zu 10\%.
Validation nur für die sets auf denen das Hyperparameter Tuning gemacht wurde
[ungefähres ]


Features:
NextStep einfach alle \(n\)--Tupel, die ein Track hergibt, sodass es noch ein Label geben würde
Separator: Muss unterschieden werden - Filtern oder nicht filtern, danach ob es das letzte mögliche Tupel vor der prediction Phase ist.
Mit filtern besseres ergebnis, aber auch deutlich weniger Trainingsbeispiele (Overfitting wird mehr zur Gefahr)
Ohne Filtern: Flexibler und mehr Trainingsbeispiele - man könnte im Nachhinen den PredictionCutOff verlegen 
und einfach das Netz weiter verwenden ohne neu zu trainieren.
Maybe ein Mittelding, das man nicht alle tupel nimmt aber auch nicht nur die letzten? Ausblick, zukunft
\todo[inline]{Example: Gegeben ein Track, was für Features würden da rausfallen}


Labels:
Sehr straight forward für NextStep (Literally), einfach die nächste Zeile im Track jeweils für X und Y

für separator slightly more complicated: 
Element des Tracks vor und hinter der Separator position (entlang der Travel Achse)

Schnittpunkt geometrisch bestimmen.
Label für position ist die Position entlang der Achse orthogonal zur Bewegungsrichtung vom Schnittpunkt der Separatorlinie und 
der Strecke zwischen dem Element vor und dem element hinter. siehe \ref{fig:Schnittpunkt}


\begin{figure}
	\centering
	% \missingfigure{geometrische Bestimmung des Schnittpunkts mit dem Separator}
	\includegraphics[width=\textwidth]{geometrie}
	\caption{Geometrische Bestimmung der Labels [Vorlage aus Florians Diss - wie QUELLE?]}
	% \todo{Quelle - test?}
	\label{fig:Schnittpunkt}
\end{figure}

\todo{table of size of different data sets - number of pictures...}

Verhältnis: Anzahl Feature-Label-Paare für verschiedene Beispiele und verschiedene Settings
(FeatureSize, Filter Ja/Nein, Augmentation Ja/Nein) Als Tabelle?

OUTDATED:
Bei einer FeatureSize von 5 ergeben sich bei den Kugeln so 98.966 Feature-Label Paare.
Die Pfefferkörner haben dann 105.101 Feature-Label Paare,
bei den Zylindern kommt man auf 244.422 Feature-Label Paare
und bei den Weizenkörner 132.140 Feature-Label Paare.
